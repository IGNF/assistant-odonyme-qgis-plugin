# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RenommeRue
                                 A QGIS plugin
 plugin de renommage des noms de rues droite et/ou gauche
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-12-11
        git sha              : $Format:%H$
        copyright            : (C) 2023 by PECHEUR Gérôme
        email                : gerome.pecheur@ign.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import copy
from datetime import datetime
import time
# from re import match

from PyQt5.QtWidgets import QPushButton
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
# from qgis.core import *
from qgis.core import QgsSingleSymbolRenderer , QgsFeatureRenderer,QgsExpression,Qgis
# from qgis.gui import QgsOptionsDialogBase

from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import QIcon, QColor, QGuiApplication,QMouseEvent
from qgis.PyQt.QtWidgets import QAction, QMainWindow, QMessageBox
# import pour construction d'un graph
from qgis.analysis import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .RenommeRue_dialog import RenommeRueDialog
from .aproposde import Aproposde
import os.path

from qgis import processing

from .fonction import *
from .cheminpluscourt import *
from .constante import *
from .tableur import *
from .event import *

# recuperation de l'id de la transaction (à partir du plugin espace co)
def getidtransaction():
    from qgis.utils import plugins
    idtransaction = None
    try:
        processing_plugin = plugins[PLUGIN_ESPACE_CO]
        try:
            idtransaction = processing_plugin.getlibelletransaction()
        except AttributeError:
            idtransaction = "Récuperation en cours de développement"
    except KeyError:
        pass

    if idtransaction is None:
        return "Pas de transaction vers la BDUNI (travail hors ligne)"
    else:
        return idtransaction

class RenommeRue:
    """QGIS Plugin Implementation."""

    def afficheMessageBar(self, message):
        self.iface.messageBar().pushMessage("Info", message, level=Qgis.Info, duration=5)

    def set_activeLayerRoute(self):
        project = QgsProject.instance()
        layer = project.mapLayersByName(LAYER_ROUTE)
        if not layer:
            return False
        else:
            self.iface.setActiveLayer(layer[0])
            self.layer = self.iface.activeLayer()
            return True

    def runchepluscourt(self):
        if not self.insee:
            afficheerreur("Veuillez renseigner le code INSEE coorespondant à la commune en cours de traitement")
        else:
            self.cheminpluscourt.cheminpluscourt()
            # ne selctionner que les troncons avec le bon INSEE
            id_insseG = self.layer.fields().indexFromName(INSEE_G)
            id_insseD = self.layer.fields().indexFromName(INSEE_D)
            listid = []
            for sel in self.layer.selectedFeatures():
                attr = sel.attributes()
                if attr[id_insseG] == self.insee or attr[id_insseD] == self.insee:
                    listid.append(sel.id())
            self.layer.selectByIds(listid)
        # re activation du layer route apres traitement
        layer = QgsProject.instance().mapLayersByName(LAYER_ROUTE)
        self.iface.setActiveLayer(layer[0])
        # zoom sur la selection
        self.iface.actionZoomToSelected().trigger()

    def colorchange(self):
        self.actualiserSelection()

    def selmemenom(self):

        if self.insee == "":
            afficheerreur("Veuillez renseigner l'INSEE de la commune à traiter", "Erreur")
            return

        # TODO sel_memenom
        QGuiApplication.setOverrideCursor(Qt.WaitCursor)
        # definition des parametres de selection (INSEE et NOM RUE)
        id_nom_rue_g = self.layer.fields().indexFromName(NOM_COLLAB_G)
        id_nom_rue_d = self.layer.fields().indexFromName(NOM_COLLAB_D)
        id_cleabs = self.layer.fields().indexFromName(CLEABS)

        # pour l'instant, on traite que s'il y a un seul (ou plus, mais ignoré) troncon de selectionné
        objets_selection = self.layer.selectedFeatures()
        attr = objets_selection[0].attributes()
        # parametres de la selection en fct des attributs du premier objet selectionné
        nom_g = attr[id_nom_rue_g]
        nom_d = attr[id_nom_rue_d]
        cleabs = attr[id_cleabs]

        # si le nom comporte un apostrphe, on reformate pour etre prit en charge par la requete
        newnom_g = nom_g.replace("'", "''")
        newnom_d = nom_d.replace("'", "''")

        # les noms vides et NULL ne sont ainsi pas selectionnés par les requetes
        if newnom_g == "":
            newnom_g = "##"
        if newnom_d == "":
            newnom_d = "##"
        if newnom_g == "NULL":
            newnom_g = "##"
        if newnom_d == "NULL":
            newnom_d = "##"
        # selection de troncon avec insee g OU d = insee commune à traiter (à voir pour le OU)
        expr1 = QgsExpression(f"{NOM_COLLAB_G} = '{newnom_g}' and {INSEE_G} = '{self.insee}'")
        expr2 = QgsExpression(f"{NOM_COLLAB_D} = '{newnom_d}' and {INSEE_D} = '{self.insee}'")
        it1 = self.layer.getFeatures(QgsFeatureRequest(expr1))
        it2 = self.layer.getFeatures(QgsFeatureRequest(expr2))
        ids1 = [i.id() for i in it1]
        ids2 = [i.id() for i in it2]
        ids1.extend(ids2)
        self.layer.selectByIds(ids1)

        # si la selection est vide c'est que les insee des troncons sont differents de celui de la commune
        if self.layer.selectedFeatureCount() == 0:
            afficheerreur("Pas de sélections :\n - verifiez que vous êtes bien dans la commune choisie"
                          "\n- Verifiez que les noms collaboratifs (droite ou gauche) soient différents de vide ou de NULL", "Erreur")

        self.iface.actionZoomToSelected().trigger()
        QGuiApplication.restoreOverrideCursor()
        # les combobox sont actualisés par l'evenement selectionchanged

    def createpoint(self):

        # self.layer.startEditing()
        #
        # obj = QgsFeature(self.layer.fields())
        # obj.setGeometry(QgsPointXY(471093, 6739160))
        # idnature = self.layer.fields().indexFromName('nature')
        # obj.setAttribute(idnature, "Antenne")
        # self.layer.addFeature(obj)
        #
        # self.layer.commitChanges()
        pass


    def renomme(self):
        # TODO renomme
        if self.insee == "":
            afficheerreur("Veuillez renseigner l'INSEE de la commune à traiter", "Erreur")
            return

        # sauvegarde des objets avant le renommage pour gerer le undo et re_seltroncon
        # car actualiseselection vide le dicoselection  apres le renommage
        self.dicoSelectionAvantModif = copy.deepcopy(self.dicoSelection)

        iDnomruegauche = self.layer.fields().indexFromName(NOM_COLLAB_G)
        iDnomruegdroite = self.layer.fields().indexFromName(NOM_COLLAB_D)

        # si le fichier de log est ouvert on quitte. il faut le fermer manuellement
        if not self.tableur.log_is_open():
            afficheerreur("fichier deja ouvert")
            return
        ligne_excel = []

        # passer en mode edition
        self.layer.startEditing()



        # on boucle sur le dico
        # si le insee g ou d == insee commune -> on renomme
        gotransactionGauche = False
        gotransactionDroit = False
        troncon_modif_hors_commune = False
        log = datetime.today().strftime('%Y-%B-%d %H:%M:%S') + "\n"
        for cle, valeur in self.dicoSelection.items():
            log += "\t" + cle + "\n"
            # expr = QgsExpression("{} = '{}'".format(CLEABS, cle))
            expr = QgsExpression(f"{CLEABS} = '{cle}'")
            objiterator = self.layer.getFeatures(QgsFeatureRequest(expr))
            ident = [i.id() for i in objiterator]

            # valeur[2] = insee gauche
            if valeur[2] == self.insee and self.isnom_G_modifie:
                gotransactionGauche = True

            # valeur[3] = insee droite
            if valeur[3] == self.insee and self.isnom_D_modifie:
                gotransactionDroit = True

            if valeur[2] != self.insee and self.isnom_G_modifie:
                troncon_modif_hors_commune = True
            if valeur[3] != self.insee and self.isnom_D_modifie:
                troncon_modif_hors_commune = True

            if troncon_modif_hors_commune:
                afficheerreur(
                    "Vous avez modifié 1 ou 2 coté(s) d'un tronçon en dehors de la commune choisie\n"
                    "Abandon du traitement")
                # on sort de la boucle mais on fait le reste
                break

            # les 2 cotés sont modifiables dans la bonne commune
            if gotransactionGauche and gotransactionDroit:
                # xlnomGinitial = valeur[0]
                # xlnomGfinal = self.dlg.comboBoxNomRueGauche.currentText()
                self.layer.changeAttributeValue(ident[0], iDnomruegauche, self.dlg.comboBoxNomRueGauche.currentText())
                log += "\t\t" + NOM_COLLAB_G + " : " + valeur[
                    0] + " --> " + self.dlg.comboBoxNomRueGauche.currentText() + "\n"

                # xlnomDinitial = valeur[0]
                # xlnomDfinal = self.dlg.comboBoxNomRueDroite.currentText()
                self.layer.changeAttributeValue(ident[0], iDnomruegdroite, self.dlg.comboBoxNomRueDroite.currentText())
                log += "\t\t" + NOM_COLLAB_D + " : " + valeur[
                    1] + " --> " + self.dlg.comboBoxNomRueDroite.currentText() + "\n"
            # 1 ou 2 cotés on etes modifié dans la bonne commune
            elif gotransactionGauche or gotransactionDroit:
                if gotransactionGauche:
                    # xlnomGinitial = valeur[0]
                    # xlnomGfinal =
                    self.layer.changeAttributeValue(ident[0], iDnomruegauche,self.dlg.comboBoxNomRueGauche.currentText())
                    log += "\t\t" + NOM_COLLAB_G + " : " + valeur[
                        0] + " --> " + self.dlg.comboBoxNomRueGauche.currentText() + "\n"

                else:
                    self.layer.changeAttributeValue(ident[0], iDnomruegdroite,self.dlg.comboBoxNomRueDroite.currentText())
                    log += "\t\t" + NOM_COLLAB_D + " : " + valeur[
                        1] + " --> " + self.dlg.comboBoxNomRueDroite.currentText() + "\n"
            # pas de transaction, 1 ou 2 cotés on etes modifié dans 1 autre commune
            else:
                # self.layer.commitChanges()
                self.dlg.pushButtonUndo.setEnabled(True)
                return

            ligne_excel.append([datetime.today().strftime('%d %B %Y %H:%M'),"En cours de dévo",cle,
                                    valeur[0],
                                    self.dlg.comboBoxNomRueGauche.currentText(),
                                    valeur[1],
                                    self.dlg.comboBoxNomRueDroite.currentText()])

        # ajout de toutes les ligne en une fois dans le fichier
        self.tableur.adddonnees(ligne_excel)
        self.tableur.sauvegarder()
        log += "\n"

        self.layer.commitChanges()
        self.re_seltroncon(self.dicoSelectionAvantModif.keys())
        nbSelection = self.layer.selectedFeatureCount()

        message = f"Le renommage é été effectué sur : {nbSelection} objet(s)"
        self.iface.messageBar().pushMessage("Info", message, level=Qgis.Info, duration=10)
        self.dlg.pushButtonUndo.setEnabled(True)

        self.iface.actionZoomToSelected().trigger()
        ecrire_debut_fichier(log)
        ecrire_debut_fichier("Numéro de la transaction = " + str(getidtransaction()) + "\n")



    # est-ce un troncon modifiable (rte 1 chaussée, rte 2 chaussées, rte empierré, chemin, sentier, autoroute,bretelle,escalier) ?
    def istroncon(self, selection):
        idnature = self.layer.fields().indexFromName('nature')
        if idnature == -1:
            return False
        elif selection[NATURE] == RTE_2_CHAUSSEES \
                or selection[NATURE] == RTE_1_CHAUSSEE \
                or selection[NATURE] == EMPIERREE \
                or selection[NATURE] == CHEMIN \
                or selection[NATURE] == SENTIER \
                or selection[NATURE] == BRETELLE \
                or selection[NATURE] == ESCALIER \
                or selection[NATURE] == AUTOROUTE \
                or selection[NATURE] == ROND_POINT:
            return True
        else:
            return False

    def setinsee(self,insee):
        # si insse n'est pas de type entier
        isvalide = True
        if any(caractere.isalpha() for caractere in insee):
            isvalide = False

        if self.dlg.lineEditINSEE.text() =="" and isvalide:
            self.dlg.lineEditINSEE.setText(str(insee))
            self.insee = str(insee)


    def actualiserSelection(self):
        # TODO actualiserSelection

        # if not self.set_activeLayerRoute():
        #     return
        # on initialise le combobox et les linedeit

        # on decoche ici sinon g est rempli avec droit et inversement
        self.dlg.checkBoxCadenas.setChecked(True)

        # on re "clic_in_zone_text" initialise à chaque actualisation de la selection
        self.custom_line_edit_combo_g.set_clic_in_zone_text(False)
        self.custom_line_edit_combo_d.set_clic_in_zone_text(False)

        self.dlg.comboBoxNomRueGauche.clear()
        self.dlg.comboBoxNomRueDroite.clear()

        nbselection = self.layer.selectedFeatureCount()
        # on active les boutons qu'il faut en fonction de la selection
        if nbselection == 0:
            self.dlg.pushButtonModifier.setEnabled(False)
            self.dlg.pushButtonModifier.setStyleSheet('color: grey')
            self.dlg.pushButtonTrajCourt.setEnabled(False)
            self.dlg.pushButtonTrajCourt.setStyleSheet('color: grey')
            self.dlg.pushButtonmemenom.setEnabled(False)
            self.dlg.pushButtonmemenom.setStyleSheet('color: grey')

        elif nbselection == 1:
            self.dlg.pushButtonmemenom.setEnabled(True)
            self.dlg.pushButtonmemenom.setStyleSheet('color: black')
            self.dlg.pushButtonTrajCourt.setEnabled(False)
            self.dlg.pushButtonTrajCourt.setStyleSheet('color: grey')

        elif nbselection == 2:
            self.dlg.pushButtonTrajCourt.setEnabled(True)
            self.dlg.pushButtonTrajCourt.setStyleSheet('color: black')
            self.dlg.pushButtonmemenom.setEnabled(False)
            self.dlg.pushButtonmemenom.setStyleSheet('color: grey')

        else:
            self.dlg.pushButtonmemenom.setEnabled(False)
            self.dlg.pushButtonmemenom.setStyleSheet('color: grey')
            self.dlg.pushButtonTrajCourt.setEnabled(False)
            self.dlg.pushButtonTrajCourt.setStyleSheet('color: grey')

        # retrouver l'index des champs nom rue G et D
        idnomruegauche = self.layer.fields().indexFromName(NOM_COLLAB_G)
        idnomruedroite = self.layer.fields().indexFromName(NOM_COLLAB_D)
        idinseeruedroite = self.layer.fields().indexFromName(INSEE_D)
        idinseeruegauche = self.layer.fields().indexFromName(INSEE_G)
        idcleabs = self.layer.fields().indexFromName(CLEABS)

        list_nom_rue_d = []
        list_nom_rue_g = []

        list_insee = []

        self.dicoSelection.clear()
        objets_selection = self.layer.selectedFeatures()

        couleur = self.dlg.mColorButton.color()
        self.iface.mapCanvas().setSelectionColor(couleur)

        for selection in objets_selection:
            attr = selection.attributes()
            if self.istroncon(selection):
                # initialisation du dico avec la selection
                self.dicoSelection[attr[idcleabs]] = [attr[idnomruegauche], attr[idnomruedroite],
                                                      attr[idinseeruegauche], attr[idinseeruedroite]]

                # ajout des noms de rues aux listes (pour traiter les occurences)
                list_nom_rue_d.append(attr[idnomruedroite])
                list_nom_rue_g.append(attr[idnomruegauche])

                # test des insee des troncons
                # si tous identique on renseigne le lineeditinsee s'il est vide
                # sinon ca veut dire que l'operateur à choisi manuellement un insee
                list_insee.append(attr[idinseeruegauche])
                list_insee.append(attr[idinseeruedroite])
                if len(set(list_insee)) == 1:
                    self.setinsee(list_insee[0])
                else:
                    self.setinsee("")

                if attr[idnomruegauche] == NULL:
                    self.dlg.comboBoxNomRueGauche.addItem("")

                elif attr[idnomruedroite] == NULL:
                    self.dlg.comboBoxNomRueDroite.addItem("")
                else:

                    self.dlg.comboBoxNomRueGauche.addItem(attr[idnomruegauche])
                    self.dlg.comboBoxNomRueDroite.addItem(attr[idnomruedroite])
                    # recuperation du nom AVANT changement dans le combobox pour gestion de l'annuler

        self.nomrueGSelection = self.dlg.comboBoxNomRueGauche.currentText()
        self.nomrueDselection = self.dlg.comboBoxNomRueDroite.currentText()

        # on trie les combobox par ordre alphabetique
        self.dlg.comboBoxNomRueGauche.model().sort(0, QtCore.Qt.AscendingOrder)
        self.dlg.comboBoxNomRueDroite.model().sort(0, QtCore.Qt.AscendingOrder)

        # si on trouve un nombre d'occurences different du nombre des noms de rues = tous les noms ne sont pas
        # identiques
        nb_occurence_nom_d = list_nom_rue_d.count(self.dlg.comboBoxNomRueDroite.currentText())
        nb_occurence_nom_g = list_nom_rue_g.count(self.dlg.comboBoxNomRueGauche.currentText())
        if nb_occurence_nom_d != len(list_nom_rue_d):
            self.dlg.labelexclamation_d.show()
        else:
            self.dlg.labelexclamation_d.hide()
        if nb_occurence_nom_g != len(list_nom_rue_g):
            self.dlg.labelexclamation_g.show()
        else:
            self.dlg.labelexclamation_g.hide()

        self.dlg.comboBoxNomRueGauche.setStyleSheet(CUSTOM_WIDGETS[1])
        self.dlg.comboBoxNomRueDroite.setStyleSheet(CUSTOM_WIDGETS[1])

        # À ce stade le nom dans la combobox n'a pas été modifié par "comboboxchange"
        # donc on désactive le renommage
        self.dlg.pushButtonModifier.setEnabled(False)
        self.dlg.pushButtonModifier.setStyleSheet('color: grey')

        # actualise le label du nombre des troncons séléctionnés
        self.dlg.labelNbTronconSel.setText(f"Vous avez sélectionné : <span style='color: red'><b>{self.layer.selectedFeatureCount()}</b></span> tronçon(s)")


    def re_seltroncon(self, listcleabs):
        # TODO re_seltroncon

        # on selectionne les troncons avec les cleabs recuperés avant les changements d'attributs
        for cleabs in listcleabs:
            # self.layer.selectByExpression("{} = '{}'".format(CLEABS, cleabs), QgsVectorLayer.AddToSelection)
            self.layer.selectByExpression(f"{CLEABS} = '{cleabs}'", QgsVectorLayer.AddToSelection)

    def afficheAProposeDe(self):
        self.dlgAProposDe.show()

    def undo(self):
        # TODO undo
        self.layer.startEditing()

        # si le fichier de log est ouvert on quitte. il faut le fermer manuellement
        if not self.tableur.log_is_open():
            return
        # ligne pour fichier excel
        ligne_excel = []

        iDnomruegauche = self.layer.fields().indexFromName(NOM_COLLAB_G)
        iDnomruegdroite = self.layer.fields().indexFromName(NOM_COLLAB_D)
        log = datetime.today().strftime('%Y-%B-%d %H:%M:%S') + "\n"
        for cle, valeur in self.dicoSelectionAvantModif.items():
            log += "\t" + cle + "\n"
            # expr = QgsExpression("{} = '{}'".format(CLEABS, cle))
            expr = QgsExpression(f"{CLEABS} = '{cle}'")
            objiterator = self.layer.getFeatures(QgsFeatureRequest(expr))
            ident = [i.id() for i in objiterator]
            # valeur[0] = nom G
            # valeur[1] = nom D

            # recuperation des attributs actuels du tronçon pour gerer le log
            entite = self.layer.getFeature(ident[0])

            # test si le nom G a vraiment été modifié
            if entite[NOM_COLLAB_G] != valeur[0]:
                self.layer.changeAttributeValue(ident[0], iDnomruegauche, valeur[0])
                log += "\t\t" + NOM_COLLAB_G + " : " + entite[NOM_COLLAB_G] + " --> " + valeur[0] + "\n"

            # test si le nom D a vraiment été modifié
            if entite[NOM_COLLAB_D] != valeur[1]:
                self.layer.changeAttributeValue(ident[0], iDnomruegdroite, valeur[1])
                log += "\t\t" + NOM_COLLAB_D + " : " + entite[NOM_COLLAB_D] + " --> " + valeur[1] + "\n"

            ligne_excel.append([datetime.today().strftime('%d %B %Y %H:%M'),"En cours de dévo", cle,
                                    entite[NOM_COLLAB_G],
                                    valeur[0],
                                    entite[NOM_COLLAB_D],
                                    valeur[1]])

        self.tableur.adddonnees(ligne_excel)
        self.tableur.sauvegarder()


        log += "\n"

        self.layer.commitChanges()
        self.re_seltroncon(self.dicoSelectionAvantModif.keys())
        self.iface.actionZoomToSelected().trigger()
        ecrire_debut_fichier(log)
        ecrire_debut_fichier("Numéro de la transaction = " + str(getidtransaction()) + "\n")

        self.dlg.pushButtonUndo.setEnabled(False)
        self.dicoSelectionAvantModif.clear()

    def lineeditINSEEChange(self):
        self.insee = self.dlg.lineEditINSEE.text()
        if any(caractere.isalpha() for caractere in self.insee):
            afficheerreur("Veuillez renseigner uniquement des chiffres")
            self.dlg.lineEditINSEE.setText("")

    def comboboxchange_droit(self):
        # on ajoute dans le G que si on a cliqué manuellement dans le combo(zone de texte)
        # et non avec actualiser selection
        if self.dlg.checkBoxCadenas.isChecked() and self.custom_line_edit_combo_d.clic_in_zone_text():
            self.dlg.comboBoxNomRueGauche.setCurrentText(self.dlg.comboBoxNomRueDroite.currentText())
        self.comboboxchange()

    def comboboxchange_gauche(self):
        # on ajoute dans le D que si on a cliqué manuellement dans le combo(zone de texte)
        # et non avec actualiser selection
        if self.dlg.checkBoxCadenas.isChecked() and self.custom_line_edit_combo_g.clic_in_zone_text():
            self.dlg.comboBoxNomRueDroite.setCurrentText(self.dlg.comboBoxNomRueGauche.currentText())
        self.comboboxchange()

    def modify_text_via_method(self):
        """Simule une modification via une méthode"""
        self.line_edit.setText("Texte modifié par méthode")


    def comboboxchange(self):
        # TODO comboboxchange
        # on a modifié le nom dans le combobox
        if self.layer.selectedFeatureCount()==0:
            return

        if self.nomrueGSelection != self.dlg.comboBoxNomRueGauche.currentText():
            self.dlg.pushButtonModifier.setEnabled(True)
            self.dlg.pushButtonModifier.setStyleSheet('color: blue')
            self.dlg.comboBoxNomRueGauche.setStyleSheet(CUSTOM_WIDGETS[0])
            self.isnom_G_modifie = True
        else:
            self.dlg.comboBoxNomRueGauche.setStyleSheet(CUSTOM_WIDGETS[1])
            self.dlg.pushButtonModifier.setEnabled(False)
            self.dlg.pushButtonModifier.setStyleSheet('color: grey')
            self.isnom_G_modifie = False

        if self.nomrueDselection != self.dlg.comboBoxNomRueDroite.currentText():
            self.dlg.pushButtonModifier.setEnabled(True)
            self.dlg.pushButtonModifier.setStyleSheet('color: blue')
            self.dlg.comboBoxNomRueDroite.setStyleSheet(CUSTOM_WIDGETS[0])
            self.isnom_D_modifie = True
        else:
            self.dlg.comboBoxNomRueDroite.setStyleSheet(CUSTOM_WIDGETS[1])
            self.dlg.pushButtonModifier.setEnabled(True)
            self.dlg.pushButtonModifier.setStyleSheet('color: blue')
            self.isnom_D_modifie = False

        if self.isnom_G_modifie or self.isnom_D_modifie:
            self.dlg.pushButtonModifier.setEnabled(True)
            self.dlg.pushButtonModifier.setStyleSheet('color: blue')
        else:
            self.dlg.pushButtonModifier.setEnabled(False)
            self.dlg.pushButtonModifier.setStyleSheet('color: grey')

    def afficher_sens_num(self):
        #     TODO afficher_sens_num

        if self.is_affiche_sens_num:
            self.dlg.pushButtonsensNumerisation.setText("Afficher le sens de numerisation")
            self.layer.loadNamedStyle(os.path.dirname(__file__) + "\sauvegarde_style_route.qml")
            self.is_affiche_sens_num = False
        else:
            self.dlg.pushButtonsensNumerisation.setText("Masquer le sens de numerisation")
            self.layer.saveNamedStyle(os.path.dirname(__file__) + "\sauvegarde_style_route.qml")
            self.layer.loadNamedStyle(os.path.dirname(__file__) + "\style_sens_numerisation.qml")
            self.is_affiche_sens_num = True

        self.layer.triggerRepaint()


    def __init__(self, iface):

        """Constructor.
    
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        # zone de texte perso du combobox
        self.custom_line_edit_combo_g = None
        self.custom_line_edit_combo_d = None


        # boolean pour afficher/masquer le sens de numerisation
        self.is_affiche_sens_num = False
        # class du tableur
        self.tableur = None

        # copie du dictionnaire de selection AVANT de renommer pour gerer le undo sur les id
        self.cheminpluscourt = None

        self.isnom_G_modifie = False
        self.isnom_D_modifie = False

        self.insee = ""
        self.dicoSelection = {}
        self.dicoSelectionAvantModif = {}
        # self.listCleabsSelectionAvantModif = []
        self.nomrueDselection = None
        self.nomrueGSelection = None

        # self.projectionLayer = None
        # self.projectionProjet = None

        # objets et avant renommage
        self.featuresAvantModif = None

        # self.menuIGN = None
        self.actionRenommeRue = None

        self.dlg = None
        self.dlgAProposDe = None

        # TEST
        # self.event = Eventwidget(self)
        # self.line_edit = self.dlg.comboBoxNomRueGauche.lineEdit()

        # self.dialvisible = None

        self.iface = iface
        self.layer = None

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'RenommeRue_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        # self.actions = []
        # self.menu = self.tr(u'&Assistant odonyme')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = True

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('RenommeRue', message)

    def initGui(self):
        pass


    def unload(self):
        pass


    def run(self):
        """Run method that performs all the real work"""
        if not QgsProject.instance().fileName():
            afficheerreur("Veuillez charger un projet")
            return

        if not self.set_activeLayerRoute():
            afficheerreur(f"la couche \"{LAYER_ROUTE}\" n'est pas activée")
            return
        else:
            self.layer = self.iface.activeLayer()

        self.layer = self.iface.activeLayer()

        # si la couche n'est pas chargée, on quitte
        if self.layer.name() != LAYER_ROUTE:
            self.afficheMessageBar("La couche routier n'est pas activée, veuillez la sélectionner")
            afficheerreur("Veuillez charger un projet et/ou activer la couche des tronçons de route")
            return

        # self.projectionLayer = self.layer.crs()
        # projet = QgsProject.instance()
        # self.projectionProjet = projet.crs()

        # evenement de changement de selection pour actualiser la selection des Qcombobox
        self.iface.mapCanvas().selectionChanged.connect(self.actualiserSelection)

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start:
            self.first_start = False
            self.dlg = RenommeRueDialog()
            # self.dlg.setStyleSheet(FOND_DIAL)

            self.cheminpluscourt = cheminpluscourt(self.iface, self.layer)

            self.tableur = Tableur()

            self.dlgAProposDe = Aproposde()
            # self.dlgAProposDe.setStyleSheet(FOND_DIAL)
            self.dlgAProposDe.setWindowFlags(Qt.WindowStaysOnTopHint)
            self.dlgAProposDe.pushButtonAffichedoc.clicked.connect(afficheDoc)
            self.dlgAProposDe.setWindowTitle(TITRE)

            self.dlg.setWindowTitle(TITRE)
            self.dlg.label_nom_rue_droite.setStyleSheet(CUSTOM_WIDGETS[3])
            self.dlg.label_nom_rue_gauche.setStyleSheet(CUSTOM_WIDGETS[3])

            # widget color
            self.dlg.mColorButton.setColor(self.iface.mapCanvas().selectionColor())
            self.dlg.mColorButton.colorChanged.connect(self.colorchange)

            # redefinir des zones de texte pour chaque combobox
            # permet de gerer les evenement clic
            # indispensable pour differencier le remplissage par clavier ou par setText (actualiserselection)
            self.custom_line_edit_combo_g = CustomLineEdit(self.dlg)
            self.dlg.comboBoxNomRueGauche.setLineEdit(self.custom_line_edit_combo_g)
            self.custom_line_edit_combo_d = CustomLineEdit(self.dlg)
            self.dlg.comboBoxNomRueDroite.setLineEdit(self.custom_line_edit_combo_d)

            # initialisation du label nb selection
            self.dlg.labelNbTronconSel.setText("")
            # rempli les QComboBox avec la sélection à l'ouverture du dial
            self.actualiserSelection()

            # À la premiere ouverture, on ne peut pas renommer
            self.dlg.pushButtonModifier.setEnabled(False)
            self.dlg.pushButtonModifier.setStyleSheet('color: grey')

            # on masque par defaut le warning exclamation
            self.dlg.labelexclamation_d.setStyleSheet('color: red')
            self.dlg.labelexclamation_g.setStyleSheet('color: red')
            self.dlg.labelexclamation_d.hide()
            self.dlg.labelexclamation_g.hide()

            # checkbox pour lier les nom_collaboratif droit et gauche
            self.dlg.checkBoxCadenas.setChecked(True)

            # evenement de la combobox
            self.dlg.comboBoxNomRueGauche.currentTextChanged.connect(self.comboboxchange_gauche)
            self.dlg.comboBoxNomRueDroite.currentTextChanged.connect(self.comboboxchange_droit)

            # evenement du lineeditINSEE
            self.dlg.lineEditINSEE.textChanged.connect(self.lineeditINSEEChange)
            self.dlg.lineEditINSEE.setStyleSheet(CUSTOM_WIDGETS[2])

            self.dlg.comboBoxNomRueGauche.setStyleSheet(CUSTOM_WIDGETS[1])
            self.dlg.comboBoxNomRueDroite.setStyleSheet(CUSTOM_WIDGETS[1])


            # Bouton : renomme la rue
            self.dlg.pushButtonModifier.clicked.connect(self.renomme)

            # Bouton de selection du chemin le plus court entre 2 troncons
            self.dlg.pushButtonTrajCourt.clicked.connect(self.runchepluscourt)

            # bouton de selection des troncons portant le meme nom de rue
            self.dlg.pushButtonmemenom.clicked.connect(self.selmemenom)

            # bouton UNDO, et desactiver au lancement
            self.dlg.pushButtonUndo.setEnabled(False)
            self.dlg.pushButtonUndo.clicked.connect(self.undo)

            # bouton a propos de
            self.dlg.pushButtonAide.clicked.connect(self.afficheAProposeDe)

            # bouton log
            self.dlg.pushButtonLog.clicked.connect(afficherlog)

            # bouton sens de numérisation
            self.dlg.pushButtonsensNumerisation.clicked.connect(self.afficher_sens_num)
            # sauvegarde du style de la couche route
            self.layer.saveNamedStyle(os.path.dirname(__file__) + "\sauvegarde_style_route.qml")


            # affiche le dial au premier plan
            self.dlg.setWindowFlags(Qt.Window | Qt.WindowStaysOnTopHint)

            # self.dialvisible = True
            self.dlg.show()


            # Run the dialog event loop
            result = self.dlg.exec_()
            # fermeture dialogue
            if result == 0:
                self.layer.loadNamedStyle(os.path.dirname(__file__) + "\sauvegarde_style_route.qml")
                self.layer.triggerRepaint()
                self.dlgAProposDe.hide()
                self.insee = ""
                self.is_affiche_sens_num = False
                # self.dialvisible = False
            self.first_start = True
            # See if OK was pressed
            if result:
                # Do something useful here - delete the line containing pass and
                # substitute with your code.
                pass
