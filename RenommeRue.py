# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RenommeRue
                                 A QGIS plugin
 plugin de renommage des noms de rues droite et/ou gauche
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-12-11
        git sha              : $Format:%H$
        copyright            : (C) 2023 by PECHEUR Gérôme
        email                : gerome.pecheur@ign.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.core import QgsExpression,Qgis,QgsMapLayer
from qgis.PyQt.QtCore import *
# import pour construction d'un graph
from qgis.analysis import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .RenommeRue_dialog import RenommeRueDialog
from .aproposde import Aproposde
import os.path

from .fonction import *
from .cheminpluscourt import *
from .constante import *
from .event import *

# recuperation de l'id de la transaction (à partir du plugin espace co)
def getidtransaction():
    from qgis.utils import plugins
    idtransaction = None
    try:
        processing_plugin = plugins[PLUGIN_ESPACE_CO]
        try:
            idtransaction = processing_plugin.getlibelletransaction()
        except AttributeError:
            idtransaction = "Récuperation en cours de développement"
    except KeyError:
        pass

    if idtransaction is None:
        return "Pas de transaction vers la BDUNI (travail hors ligne)"
    else:
        return idtransaction

class RenommeRue:
    """QGIS Plugin Implementation."""

    def afficheMessageBar(self, message):
        self.iface.messageBar().pushMessage("Info", message, level=Qgis.Info, duration=5)

    def set_activeLayerRoute(self):
        project = QgsProject.instance()
        layer = project.mapLayersByName(LAYER_ROUTE)
        if not layer:
            return False
        else:
            self.iface.setActiveLayer(layer[0])
            self.layer = self.iface.activeLayer()
            return True

    def runchepluscourt(self):
        if not self.insee_commune:
            afficheerreur("Veuillez renseigner le code INSEE coorespondant à la commune en cours de traitement")
        else:
            self.cheminpluscourt.cheminpluscourt()
            # ne selctionner que les troncons avec le bon INSEE
            id_insseG = self.layer.fields().indexFromName(INSEE_G)
            id_insseD = self.layer.fields().indexFromName(INSEE_D)
            listid = []
            for sel in self.layer.selectedFeatures():
                attr = sel.attributes()
                if attr[id_insseG] == self.insee_commune or attr[id_insseD] == self.insee_commune:
                    listid.append(sel.id())
            self.layer.selectByIds(listid)
        # re activation du layer route apres traitement
        layer = QgsProject.instance().mapLayersByName(LAYER_ROUTE)
        self.iface.setActiveLayer(layer[0])
        # zoom sur la selection
        self.iface.actionZoomToSelected().trigger()

    def colorchange(self):
        self.actualiserSelection()
        
    def selmemenom(self):

        if self.insee_commune == "":
            afficheerreur("Veuillez renseigner l'INSEE de la commune à traiter", "Erreur")
            return

        # TODO sel_memenom
        QGuiApplication.setOverrideCursor(Qt.WaitCursor)
        # definition des parametres de selection (INSEE et NOM RUE)
        id_nom_rue_g = self.layer.fields().indexFromName(NOM_COLLAB_G)
        id_nom_rue_d = self.layer.fields().indexFromName(NOM_COLLAB_D)
        id_cleabs = self.layer.fields().indexFromName(CLEABS)

        # pour l'instant, on traite que s'il y a un seul (ou plus, mais ignoré) troncon de selectionné
        attr = self.layer.selectedFeatures()[0].attributes()

        # parametres de la selection en fct des attributs du premier objet selectionné
        nom_g = attr[id_nom_rue_g]
        nom_d = attr[id_nom_rue_d]

        # si le nom comporte un apostrphe, on reformate pour etre prit en charge par la requete
        newnom_g = nom_g.replace("'", "''")
        newnom_d = nom_d.replace("'", "''")

        # les noms vides et NULL ne sont ainsi pas selectionnés par les requetes
        if newnom_g == "":
            newnom_g = "##"
        if newnom_d == "":
            newnom_d = "##"
        if newnom_g == "NULL":
            newnom_g = "##"
        if newnom_d == "NULL":
            newnom_d = "##"
        # selection de troncon avec insee g OU d = insee commune à traiter (à voir pour le OU)
        expr1 = QgsExpression(f"{NOM_COLLAB_G} = '{newnom_g}' and {INSEE_G} = '{self.insee_commune}'")
        expr2 = QgsExpression(f"{NOM_COLLAB_D} = '{newnom_d}' and {INSEE_D} = '{self.insee_commune}'")
        it1 = self.layer.getFeatures(QgsFeatureRequest(expr1))
        it2 = self.layer.getFeatures(QgsFeatureRequest(expr2))
        ids1 = [i.id() for i in it1]
        ids2 = [i.id() for i in it2]
        ids1.extend(ids2)
        self.layer.selectByIds(ids1)

        # si la selection est vide c'est que les insee des troncons sont differents de celui de la commune
        if self.layer.selectedFeatureCount() == 0:
            afficheerreur("Pas de sélections :\n - verifiez que vous êtes bien dans la commune choisie"
                          "\n- Verifiez que les noms collaboratifs (droite ou gauche) soient différents de vide ou de NULL", "Erreur")

        self.iface.actionZoomToSelected().trigger()
        QGuiApplication.restoreOverrideCursor()

    def renomme(self):
        QGuiApplication.setOverrideCursor(Qt.WaitCursor)
        if self.insee_commune == "":
            afficheerreur("Veuillez renseigner l'INSEE de la commune à traiter", "Erreur")
            return

        iDnomruegauche = self.layer.fields().indexFromName(NOM_COLLAB_G)
        iDnomruegdroite = self.layer.fields().indexFromName(NOM_COLLAB_D)
        idaliasgauche = self.layer.fields().indexFromName(ALIAS_G)
        idaliasdroit = self.layer.fields().indexFromName(ALIAS_D)

        # passer en mode edition
        self.layer.startEditing()

        # on boucle sur le dico
        # si le insee g ou d == insee commune -> on renomme
        gotransactionCollabGauche = False
        gotransactionCollabDroit = False
        gotransactionAliasGauche = False
        gotransactionAliasDroit = False

        troncon_modif_hors_commune = False
        for cle, valeur in self.dicoSelection.items():
            expr = QgsExpression(f"{CLEABS} = '{cle}'")
            objiterator = self.layer.getFeatures(QgsFeatureRequest(expr))
            ident = [i.id() for i in objiterator]

            # valeur[2] = insee gauche
            # valeur[3] = insee droite

            # on peut modifier les nom collab
            if valeur[2] == self.insee_commune and self.isnom_G_modifie:
                gotransactionCollabGauche = True
            if valeur[3] == self.insee_commune and self.isnom_D_modifie:
                gotransactionCollabDroit = True
            # on peut modifier les alias
            if valeur[2] == self.insee_commune and self.isalias_g_modifie:
                gotransactionAliasGauche = True
            if valeur[3] == self.insee_commune and self.isalias_d_modifie:
                gotransactionAliasDroit = True

            if valeur[2] != self.insee_commune and (self.isnom_G_modifie or self.isalias_g_modifie):
                troncon_modif_hors_commune = True
            if valeur[3] != self.insee_commune and (self.isnom_D_modifie or self.isalias_d_modifie):
                troncon_modif_hors_commune = True

            if troncon_modif_hors_commune:
                afficheerreur(
                    "Vous avez modifié 1 ou 2 coté(s) d'un tronçon en dehors de la commune choisie\n"
                    "Abandon du traitement")
                # on sort de la boucle, mais on fait le reste
                break

            # les 2 cotés sont modifiables dans la bonne commune
            if gotransactionCollabGauche and gotransactionCollabDroit:
                # nom collab
                self.layer.changeAttributeValue(ident[0], iDnomruegauche, self.dlg.comboBoxNomRueGauche.currentText())
                self.layer.changeAttributeValue(ident[0], iDnomruegdroite, self.dlg.comboBoxNomRueDroite.currentText())

            # 1 ou 2 cotés on etes modifié dans la bonne commune
            elif gotransactionCollabGauche or gotransactionCollabDroit:
                if gotransactionCollabGauche:
                    # nom collab gauche
                    self.layer.changeAttributeValue(ident[0], iDnomruegauche,self.dlg.comboBoxNomRueGauche.currentText())
                else:
                    # nom collabg droit
                    self.layer.changeAttributeValue(ident[0], iDnomruegdroite,self.dlg.comboBoxNomRueDroite.currentText())

            print(gotransactionAliasGauche," : ",self.isalias_g_modifie )
            if gotransactionAliasGauche and self.isalias_g_modifie:
                self.layer.changeAttributeValue(ident[0], idaliasgauche, self.dlg.lineEditAliasG.text())
            if gotransactionAliasDroit and self.isalias_d_modifie:
                self.layer.changeAttributeValue(ident[0], idaliasdroit, self.dlg.lineEditAliasD.text())

        QGuiApplication.restoreOverrideCursor()
        self.afficheMessageBar(
            f"Les modifications ont été effectués sur : {self.layer.selectedFeatureCount()} tronçon(s)")

    # est-ce un troncon modifiable (rte 1 chaussée, rte 2 chaussées, rte empierré, chemin, sentier, autoroute,bretelle,escalier) ?
    def istroncon(self, selection):
        idnature = self.layer.fields().indexFromName('nature')
        if idnature == -1:
            return False
        elif selection[NATURE] == RTE_2_CHAUSSEES \
                or selection[NATURE] == RTE_1_CHAUSSEE \
                or selection[NATURE] == EMPIERREE \
                or selection[NATURE] == CHEMIN \
                or selection[NATURE] == SENTIER \
                or selection[NATURE] == BRETELLE \
                or selection[NATURE] == ESCALIER \
                or selection[NATURE] == AUTOROUTE \
                or selection[NATURE] == ROND_POINT:
            return True
        else:
            return False

    def setinsee(self,insee):
        # si insse n'est pas de type entier
        isvalide = True
        if any(caractere.isalpha() for caractere in insee):
            isvalide = False

        if self.dlg.lineEditINSEECommune.text() =="" and isvalide:
            self.dlg.lineEditINSEECommune.setText(str(insee))
            self.insee_commune = str(insee)

    def actualiserSelection(self):
        if not self.set_activeLayerRoute():
            return

        # on decoche ici sinon g est rempli avec droit et inversement
        self.dlg.checkBoxCadenas.setChecked(True)

        # on re "clic_in_zone_text" initialise à chaque actualisation de la selection
        self.custom_line_edit_combo_g.set_clic_in_zone_text(False)
        self.custom_line_edit_combo_d.set_clic_in_zone_text(False)

        self.dlg.comboBoxNomRueGauche.clear()
        self.dlg.comboBoxNomRueDroite.clear()
        self.dlg.lineEditBanG.clear()
        self.dlg.lineEditBanD.clear()
        self.dlg.lineEditAliasG.clear()
        self.dlg.lineEditAliasD.clear()

        nbselection = self.layer.selectedFeatureCount()
        # on active les boutons qu'il faut en fonction de la selection
        if nbselection == 0:
            self.dlg.pushButtonModifier.setEnabled(False)
            # self.dlg.pushButtonModifier.setStyleSheet('color: grey')
            self.dlg.pushButtonTrajCourt.setEnabled(False)
            self.dlg.pushButtonTrajCourt.setStyleSheet('color: grey')
            self.dlg.pushButtonmemenom.setEnabled(False)
            self.dlg.pushButtonmemenom.setStyleSheet('color: grey')

        elif nbselection == 1:
            self.dlg.pushButtonmemenom.setEnabled(True)
            self.dlg.pushButtonmemenom.setStyleSheet('color: black')
            self.dlg.pushButtonTrajCourt.setEnabled(False)
            self.dlg.pushButtonTrajCourt.setStyleSheet('color: grey')

        elif nbselection == 2:
            self.dlg.pushButtonTrajCourt.setEnabled(True)
            self.dlg.pushButtonTrajCourt.setStyleSheet('color: black')
            self.dlg.pushButtonmemenom.setEnabled(False)
            self.dlg.pushButtonmemenom.setStyleSheet('color: grey')

        else:
            self.dlg.pushButtonmemenom.setEnabled(False)
            self.dlg.pushButtonmemenom.setStyleSheet('color: grey')
            self.dlg.pushButtonTrajCourt.setEnabled(False)
            self.dlg.pushButtonTrajCourt.setStyleSheet('color: grey')

        # retrouver l'index des champs nom rue G et D
        idnomruegauche = self.layer.fields().indexFromName(NOM_COLLAB_G)
        idnomruedroite = self.layer.fields().indexFromName(NOM_COLLAB_D)
        idinseeruedroite = self.layer.fields().indexFromName(INSEE_D)
        idinseeruegauche = self.layer.fields().indexFromName(INSEE_G)

        idaliasgauche = self.layer.fields().indexFromName(ALIAS_G)
        idaliasdroit = self.layer.fields().indexFromName(ALIAS_D)
        idvoiebangauche = self.layer.fields().indexFromName(VOIE_BAN_G)
        idvoiebandroite = self.layer.fields().indexFromName(VOIE_BAN_D)

        idcleabs = self.layer.fields().indexFromName(CLEABS)

        list_nom_rue_d = []
        list_nom_rue_g = []
        list_alias_g = []
        list_alias_d = []

        list_insee = []

        self.dicoSelection.clear()

        couleur = self.dlg.mColorButton.color()
        self.iface.mapCanvas().setSelectionColor(couleur)

        for selection in self.layer.selectedFeatures():
            attr = selection.attributes()
            if self.istroncon(selection):
                # initialisation du dico avec la selection
                self.dicoSelection[attr[idcleabs]] = [attr[idnomruegauche], attr[idnomruedroite],
                                                      attr[idinseeruegauche], attr[idinseeruedroite],
                                                      attr[idaliasgauche],attr[idaliasdroit]]

                # ajout des noms de rues aux listes (pour traiter les occurences)
                list_nom_rue_d.append(attr[idnomruedroite])
                list_nom_rue_g.append(attr[idnomruegauche])
                list_alias_g.append(attr[idaliasgauche])
                list_alias_d.append(attr[idaliasdroit])

                # test des insee des troncons
                # si tous identique on renseigne le lineeditinsee s'il est vide
                # sinon ca veut dire que l'operateur à choisi manuellement un insee
                list_insee.append(attr[idinseeruegauche])
                list_insee.append(attr[idinseeruedroite])
                if len(set(list_insee)) == 1:
                    self.setinsee(list_insee[0])
                else:
                    self.setinsee("")

                if attr[idnomruegauche] == NULL:
                    self.dlg.comboBoxNomRueGauche.addItem("")
                elif attr[idnomruedroite] == NULL:
                    self.dlg.comboBoxNomRueDroite.addItem("")
                elif attr[idaliasgauche] == NULL:
                    self.dlg.lineEditAliasG.setText("")
                elif attr[idaliasdroit] == NULL:
                    self.dlg.lineEditAliasD.setText("")
                else:

                    self.dlg.comboBoxNomRueGauche.addItem(attr[idnomruegauche])
                    self.dlg.comboBoxNomRueDroite.addItem(attr[idnomruedroite])
                    # LineEdit
                    self.dlg.lineEditAliasG.setText(attr[idaliasgauche])
                    self.dlg.lineEditAliasD.setText(attr[idaliasdroit])
                    self.dlg.lineEditBanG.setText(attr[idvoiebangauche])
                    self.dlg.lineEditBanD.setText(attr[idvoiebandroite])

        # recuperation du nom AVANT changement dans le combobox et edit pour
        # gerer si on a remis celui initialement.
        self.nomrueGSelection = self.dlg.comboBoxNomRueGauche.currentText()
        self.nomrueDselection = self.dlg.comboBoxNomRueDroite.currentText()
        self.aliasGSelection = self.dlg.lineEditAliasG.text()
        self.aliasDSelection = self.dlg.lineEditAliasD.text()

        # on trie les combobox par ordre alphabetique
        self.dlg.comboBoxNomRueGauche.model().sort(0, QtCore.Qt.AscendingOrder)
        self.dlg.comboBoxNomRueDroite.model().sort(0, QtCore.Qt.AscendingOrder)

        # si on trouve un nombre d'occurences different du nombre des noms de rues = tous les noms ne sont pas
        # identiques
        nb_occurence_nom_d = list_nom_rue_d.count(self.dlg.comboBoxNomRueDroite.currentText())
        nb_occurence_nom_g = list_nom_rue_g.count(self.dlg.comboBoxNomRueGauche.currentText())
        nb_occurence_alias_g = list_alias_g.count(self.dlg.lineEditAliasG.text())
        nb_occurence_alias_d = list_alias_d.count(self.dlg.lineEditAliasD.text())
        if nb_occurence_nom_d != len(list_nom_rue_d):
            self.dlg.labelexclamation_d.show()
            # l'affichage des alias et des ban est basé sur les occurences de la liste des NOM DE RUES
            self.dlg.lineEditBanD.setText("")
            self.dlg.lineEditAliasD.setText("")
        else:
            self.dlg.labelexclamation_d.hide()
        if nb_occurence_nom_g != len(list_nom_rue_g):
            self.dlg.labelexclamation_g.show()
            # l'affichage des alias et des ban est basé sur les occurences de la liste des NOM DE RUES
            self.dlg.lineEditBanG.setText("")
            self.dlg.lineEditAliasG.setText("")
        else:
            self.dlg.labelexclamation_g.hide()
        if nb_occurence_alias_g != len(list_alias_g):
            self.dlg.lineEditAliasG.setText("***")
        if nb_occurence_alias_d != len(list_alias_d):
            self.dlg.lineEditAliasD.setText("***")


        self.dlg.comboBoxNomRueGauche.setStyleSheet(CUSTOM_WIDGETS[1])
        self.dlg.comboBoxNomRueDroite.setStyleSheet(CUSTOM_WIDGETS[1])
        self.dlg.lineEditAliasG.setStyleSheet(CUSTOM_WIDGETS[1])
        self.dlg.lineEditAliasD.setStyleSheet(CUSTOM_WIDGETS[1])

        # À ce stade le nom dans la combobox n'a pas été modifié par "comboboxchange"
        # donc on désactive le renommage.
        self.dlg.pushButtonModifier.setEnabled(False)
        # self.dlg.pushButtonModifier.setStyleSheet('color: grey')

        # actualise le label du nombre des troncons séléctionnés
        self.dlg.labelNbTronconSel.setText(f"Vous avez sélectionné : <span style='color: red'><b>{self.layer.selectedFeatureCount()}</b></span> tronçon(s)")


    def re_seltroncon(self, listcleabs):
        # TODO re_seltroncon

        # on selectionne les troncons avec les cleabs recuperés avant les changements d'attributs
        for cleabs in listcleabs:
            # self.layer.selectByExpression("{} = '{}'".format(CLEABS, cleabs), QgsVectorLayer.AddToSelection)
            self.layer.selectByExpression(f"{CLEABS} = '{cleabs}'", QgsVectorLayer.AddToSelection)

    def afficheAProposeDe(self):
        self.dlgAProposDe.show()

    def lineeditINSEEChange(self):
        self.insee_commune = self.dlg.lineEditINSEECommune.text()
        if any(caractere.isalpha() for caractere in self.insee_commune):
            afficheerreur("Veuillez renseigner uniquement des chiffres")
            self.dlg.lineEditINSEECommune.setText("")

    def lineeditAliasGChange(self):
        self.widgetschange()

    def lineeditAliasDChange(self):
        self.widgetschange()

    def comboboxchange_droit(self):
        # on ajoute dans le G que si on a cliqué manuellement dans le combo(zone de texte)
        # et non avec actualiser selection
        if self.dlg.checkBoxCadenas.isChecked() and self.custom_line_edit_combo_d.clic_in_zone_text():
            self.dlg.comboBoxNomRueGauche.setCurrentText(self.dlg.comboBoxNomRueDroite.currentText())
        self.widgetschange()

    def comboboxchange_gauche(self):
        # on ajoute dans le D que si on a cliqué manuellement dans le combo(zone de texte)
        # et non avec actualiser selection
        if self.dlg.checkBoxCadenas.isChecked() and self.custom_line_edit_combo_g.clic_in_zone_text():
            self.dlg.comboBoxNomRueDroite.setCurrentText(self.dlg.comboBoxNomRueGauche.currentText())
        self.widgetschange()

    # l'utilisateur a modifié le nom de rue
    # s'il remet le meme nom, on dit qu'il n'y a pas eu de modif
    def widgetschange(self):
        if self.layer.selectedFeatureCount()==0:
            return

        # nom collab gauche est modifié
        if self.nomrueGSelection != self.dlg.comboBoxNomRueGauche.currentText():
            self.dlg.comboBoxNomRueGauche.setStyleSheet(CUSTOM_WIDGETS[0])
            self.isnom_G_modifie = True
        else:
            self.dlg.comboBoxNomRueGauche.setStyleSheet(CUSTOM_WIDGETS[1])
            self.isnom_G_modifie = False

        # nom collab droit est modifié
        if self.nomrueDselection != self.dlg.comboBoxNomRueDroite.currentText():
            self.dlg.comboBoxNomRueDroite.setStyleSheet(CUSTOM_WIDGETS[0])
            self.isnom_D_modifie = True
        else:
            self.dlg.comboBoxNomRueDroite.setStyleSheet(CUSTOM_WIDGETS[1])
            self.isnom_D_modifie = False

        # alias gauche est modifié
        if self.aliasGSelection != self.dlg.lineEditAliasG.text():
            self.dlg.lineEditAliasG.setStyleSheet(CUSTOM_WIDGETS[0])
            self.isalias_g_modifie = True
        else:
            self.dlg.lineEditAliasG.setStyleSheet(CUSTOM_WIDGETS[1])
            self.isalias_g_modifie = False

        # alias droit est modifié
        if self.aliasDSelection != self.dlg.lineEditAliasD.text():
            self.dlg.lineEditAliasD.setStyleSheet(CUSTOM_WIDGETS[0])
            self.isalias_d_modifie = True
        else:
            self.dlg.lineEditAliasD.setStyleSheet(CUSTOM_WIDGETS[1])
            self.isalias_d_modifie = False

        if self.isnom_G_modifie or self.isnom_D_modifie or self.isalias_g_modifie or self.isalias_d_modifie:
            self.dlg.pushButtonModifier.setEnabled(True)
        else:
            self.dlg.pushButtonModifier.setEnabled(False)

    def afficher_sens_num(self):
        #     TODO afficher_sens_num
        if self.is_affiche_sens_num:
            self.dlg.pushButtonsensNumerisation.setText("Afficher le sens de numerisation")
            self.layer.loadNamedStyle(os.path.join(os.path.dirname(__file__),"SENS_NUM", "sauvegarde_style_route.qml"),categories=QgsMapLayer.StyleCategory.Symbology| QgsMapLayer.Labeling)
            self.is_affiche_sens_num = False
        else:
            self.dlg.pushButtonsensNumerisation.setText("Masquer le sens de numerisation")
            self.layer.saveNamedStyle(os.path.join(os.path.dirname(__file__), "SENS_NUM", "sauvegarde_style_route.qml"),categories=QgsMapLayer.StyleCategory.Symbology| QgsMapLayer.Labeling)
            self.layer.loadNamedStyle(os.path.join(os.path.dirname(__file__), "SENS_NUM", "style_sens_numerisation.qml"),categories=QgsMapLayer.StyleCategory.Symbology| QgsMapLayer.Labeling)
            self.is_affiche_sens_num = True

        self.layer.triggerRepaint()

    def __init__(self, iface):
        # zone de texte perso du combobox
        self.custom_line_edit_combo_g = None
        self.custom_line_edit_combo_d = None

        # boolean pour afficher/masquer le sens de numerisation
        self.is_affiche_sens_num = False

        # copie du dictionnaire de selection AVANT de renommer pour gerer le undo sur les id
        self.cheminpluscourt = None

        self.isnom_G_modifie = False
        self.isnom_D_modifie = False
        self.isinsee_G_modifie = False
        self.isinsee_D_modifie = False
        self.isalias_g_modifie = False
        self.isalias_d_modifie = False

        self.insee_commune = ""
        self.insee_g = ""
        self.insee_d = ""
        self.dicoSelection = {}
        # self.listCleabsSelectionAvantModif = []
        self.nomrueDselection = None
        self.nomrueGSelection = None
        self.aliasGSelection  =None
        self.aliasDSelection = None

        self.dlg = None
        self.dlgAProposDe = None

        self.iface = iface
        self.layer = None

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'RenommeRue_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)


        self.first_start = True

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        return QCoreApplication.translate('RenommeRue', message)

    def initGui(self):
        pass

    def unload(self):
        pass

    def run(self):
        """Run method that performs all the real work"""
        if not QgsProject.instance().fileName():
            afficheerreur("Veuillez charger un projet")
            return

        if not self.set_activeLayerRoute():
            afficheerreur(f"la couche \"{LAYER_ROUTE}\" n'est pas activée")
            return
        else:
            self.layer = self.iface.activeLayer()

        self.layer = self.iface.activeLayer()

        # si la couche n'est pas chargée, on quitte
        if self.layer.name() != LAYER_ROUTE:
            self.afficheMessageBar("La couche routier n'est pas activée, veuillez la sélectionner")
            afficheerreur("Veuillez charger un projet et/ou activer la couche des tronçons de route")
            return

        # evenement de changement de selection pour actualiser la selection des Qcombobox
        self.iface.mapCanvas().selectionChanged.connect(self.actualiserSelection)

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start:
            self.first_start = False
            self.dlg = RenommeRueDialog()

            self.cheminpluscourt = cheminpluscourt(self.iface, self.layer)

            self.dlgAProposDe = Aproposde()
            self.dlgAProposDe.setWindowFlags(Qt.WindowStaysOnTopHint)
            self.dlgAProposDe.pushButtonAffichedoc.clicked.connect(afficheDoc)
            self.dlgAProposDe.setWindowTitle(f"{TITRE} {VERSION}")

            self.dlg.setWindowTitle(f"{TITRE} {VERSION}")
            self.dlg.label_nom_rue_droite.setStyleSheet(CUSTOM_WIDGETS[3])
            self.dlg.label_nom_rue_gauche.setStyleSheet(CUSTOM_WIDGETS[3])

            # widget color
            self.dlg.mColorButton.setColor(self.iface.mapCanvas().selectionColor())
            self.dlg.mColorButton.colorChanged.connect(self.colorchange)

            # redefinir des zones de texte pour chaque combobox
            # permet de gerer les evenement clic
            # indispensable pour differencier le remplissage par clavier ou par setText (actualiserselection)
            self.custom_line_edit_combo_g = CustomLineEdit(self.dlg)
            self.dlg.comboBoxNomRueGauche.setLineEdit(self.custom_line_edit_combo_g)
            self.custom_line_edit_combo_d = CustomLineEdit(self.dlg)
            self.dlg.comboBoxNomRueDroite.setLineEdit(self.custom_line_edit_combo_d)

            # initialisation du label nb selection
            self.dlg.labelNbTronconSel.setText("")
            # rempli les QComboBox avec la sélection à l'ouverture du dial
            self.actualiserSelection()

            # À la premiere ouverture, on ne peut pas renommer
            self.dlg.pushButtonModifier.setEnabled(False)
            self.dlg.pushButtonModifier.setStyleSheet(CUSTOM_WIDGETS[4])

            # on masque par defaut le warning exclamation
            self.dlg.labelexclamation_d.setStyleSheet('color: red')
            self.dlg.labelexclamation_g.setStyleSheet('color: red')
            self.dlg.labelexclamation_d.hide()
            self.dlg.labelexclamation_g.hide()

            # checkbox pour lier les nom_collaboratif droit et gauche
            self.dlg.checkBoxCadenas.setChecked(True)

            # evenement de la combobox
            self.dlg.comboBoxNomRueGauche.currentTextChanged.connect(self.comboboxchange_gauche)
            self.dlg.comboBoxNomRueDroite.currentTextChanged.connect(self.comboboxchange_droit)

            # evenement du lineEditINSEECommune
            self.dlg.lineEditINSEECommune.textChanged.connect(self.lineeditINSEEChange)
            self.dlg.lineEditINSEECommune.setStyleSheet(CUSTOM_WIDGETS[2])

            # evenement des lineedit alias
            self.dlg.lineEditAliasG.textChanged.connect(self.lineeditAliasGChange)
            self.dlg.lineEditAliasD.textChanged.connect(self.lineeditAliasDChange)

            self.dlg.comboBoxNomRueGauche.setStyleSheet(CUSTOM_WIDGETS[1])
            self.dlg.comboBoxNomRueDroite.setStyleSheet(CUSTOM_WIDGETS[1])

            # Bouton : renomme la rue
            self.dlg.pushButtonModifier.clicked.connect(self.renomme)

            # Bouton de selection du chemin le plus court entre 2 troncons
            self.dlg.pushButtonTrajCourt.clicked.connect(self.runchepluscourt)

            # bouton de selection des troncons portant le meme nom de rue
            self.dlg.pushButtonmemenom.clicked.connect(self.selmemenom)

            # bouton a propos de
            self.dlg.pushButtonAide.clicked.connect(self.afficheAProposeDe)

            # bouton sens de numérisation
            self.dlg.pushButtonsensNumerisation.clicked.connect(self.afficher_sens_num)
            # sauvegarde du style de la couche route
            self.layer.saveNamedStyle(os.path.join(os.path.dirname(__file__), "SENS_NUM", "sauvegarde_style_route.qml"))

            self.dlg.setParent(self.iface.mainWindow())
            self.dlg.setWindowFlags(Qt.Dialog | Qt.WindowTitleHint | Qt.WindowCloseButtonHint)
            self.dlg.show()


            # Run the dialog event loop
            result = self.dlg.exec_()
            # fermeture dialogue
            if result == 0:
                self.layer.loadNamedStyle(os.path.join(os.path.dirname(__file__), "SENS_NUM", "sauvegarde_style_route.qml"),categories=QgsMapLayer.StyleCategory.Symbology| QgsMapLayer.Labeling)
                self.layer.triggerRepaint()
                self.dlgAProposDe.hide()
                self.insee_commune = ""
                self.is_affiche_sens_num = False
                # self.dialvisible = False
            self.first_start = True
            # See if OK was pressed
            if result:
                # Do something useful here - delete the line containing pass and
                # substitute with your code.
                pass
